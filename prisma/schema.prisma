// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")
}

model User {
  id           Int           @id @default(autoincrement())
  email        String        @unique
  name         String
  comment      String? // A note viewable/editable by the sysadmin only.
  role         UserRole
  passwordHash String
  reservations Reservation[]
  disabled     Boolean       @default(false)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
}

enum UserRole {
  ADMIN
  CUSTOMER
  REP
}

model Branch {
  id              Int      @id @default(autoincrement())
  cars            Car[]
  name            String
  description     String
  streetAddress   String
  city            String
  region          String
  country         String
  postalCode      String
  iataAirportCode String?  @db.Char(3)
  latitude        Float
  longitude       Float
  disabled        Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model Car {
  id              Int           @id @default(autoincrement())
  branch          Branch        @relation(fields: [branchId], references: [id])
  branchId        Int
  make            String
  model           String
  year            Int
  colour          CarColour
  seats           Int
  description     String
  photo_url       String?
  // Floats can't be used for money because of floating-point rounding errors.
  // We can either keep this all prices in our schema as simple Ints and divide
  // by 100 at the end (storing the price as cents), or we can use Decimal.js
  // (but that's another dependency).
  dailyPrice      Int
  reservations    Reservation[]
  bookingDisabled Boolean       @default(false)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

enum CarColour {
  BLACK
  WHITE
  GREY
  SILVER
  GOLD
  RED
  ORANGE
  YELLOW
  GREEN
  BLUE
  PURPLE
  PINK
  MULTI
}

// Do we want to assume that all equipment is available for all cars? Or
// do we need to create a table to define that relationship? Also, do we
// need to inventory-control this equipment like we need to do for cars
// (eg. prevent double booking?) Vs. eg. a pre-paid gas refill doesn't
// need inventory control.
model Equipment {
  id              Int                            @id @default(autoincrement())
  name            String
  description     String
  // Do we want to support both flat-rate and daily pricing models?
  // Eg. pre-purchased gas refill is generally flat-rate. A trailer
  // probably has a daily charge.
  price           Int
  photo_url       String?
  reservations    ReservationIncludedEquipment[]
  bookingDisabled Boolean                        @default(false)
  createdAt       DateTime                       @default(now())
  updatedAt       DateTime                       @updatedAt
}

model Reservation {
  id                                Int                            @id @default(autoincrement())
  // Through the car, the branch can be found if needed, since a car
  // belongs to a unique branch.
  car                               Car                            @relation(fields: [carId], references: [id])
  carId                             Int
  equipment                         ReservationIncludedEquipment[]
  holder                            User                           @relation(fields: [holderId], references: [id])
  holderId                          Int
  // When a reservation is "modified", a new reservation is created with a pointer to the previous
  // reservation. A reservation that has a replacedBy reservation should not be considered active.
  // This will allow the customer and representative to see the history of changes.
  replaces                          Reservation?                   @relation("ReservationHistory", fields: [replacesId], references: [id])
  replacesId                        Int                            @unique
  replacedBy                        Reservation?                   @relation("ReservationHistory")
  // Same money considerations as above
  quotedPrice                       Int
  cancelled                         Boolean                        @default(false)
  // The optional fields following won't be filled in until check-in
  checkInNotes                      String?
  checkInLicenseNumber              String?
  checkInLicenseIssuingJurisdiction String?
  plannedDepartureAt                DateTime
  plannedReturnAt                   DateTime
  pickedUpAt                        DateTime?
  returnedAt                        DateTime?
  createdAt                         DateTime                       @default(now())
  updatedAt                         DateTime                       @updatedAt
}

model ReservationIncludedEquipment {
  reservation   Reservation @relation(fields: [reservationId], references: [id])
  reservationId Int
  equipment     Equipment   @relation(fields: [equipmentId], references: [id])
  equipmentId   Int

  @@unique([reservationId, equipmentId])
}
